(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{419:function(e,t,a){"use strict";a.r(t);var i=a(19),o=Object(i.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"polymorphism"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#polymorphism"}},[e._v("#")]),e._v(" Polymorphism")]),e._v(" "),a("h2",{attrs:{id:"type"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#type"}},[e._v("#")]),e._v(" Type")]),e._v(" "),a("ol",[a("li",[e._v("Compile: template, overload")]),e._v(" "),a("li",[e._v("Run-time: dynamic bind")])]),e._v(" "),a("h2",{attrs:{id:"why-run-time-polymorphism-only-work-with-pointer-and-reference"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#why-run-time-polymorphism-only-work-with-pointer-and-reference"}},[e._v("#")]),e._v(" Why run-time polymorphism only work with pointer and reference")]),e._v(" "),a("ol",[a("li",[e._v("In C++, an object always has a fixed type and size known at compile-time and\n(if it can and does have its address   taken) always exists at a fixed address for the duration of its lifetime")]),e._v(" "),a("li",[e._v("If use "),a("code",[e._v("Base b = Derived()")]),e._v(", the copy constructor of class Base will be used,\nthe object b is a slicing of Derived().")]),e._v(" "),a("li",[e._v("A pointer or reference, like "),a("code",[e._v("Base *b = new Derived()")]),e._v(" only points to a memory")])]),e._v(" "),a("h2",{attrs:{id:"how"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#how"}},[e._v("#")]),e._v(" How")]),e._v(" "),a("ol",[a("li",[e._v("The size of each pointer is same, 64bit or 32bit")]),e._v(" "),a("li",[e._v("The type of pointer indicate how many byte to read")]),e._v(" "),a("li",[e._v("Each class has a vtable pointer, which points to a talbe has all virtual functions")])])])}),[],!1,null,null,null);t.default=o.exports}}]);